// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
use chrono::{DateTime, Utc};
use rusqlite::{Connection, Result};
use tauri::command;

struct Persona {
    id: i32,
    nombre: String,
    data: Option<Vec<u8>>,
    fecha: Option<DateTime<Utc>>,
}

#[derive(serde::Serialize, serde::Deserialize)]
struct Paciente {
    id_paciente: i32,
    nombre_1: String,
    nombre_2: String,
    nombre_3: Option<String>,
    apellido_1: String,
    apellido_2: Option<String>,
    apellido_casado: Option<String>,
    fecha_nacimiento: String,
    direccion: String,
    telefono: String,
    genero: String,
    fecha_registro: Option<String>,
}

#[derive(serde::Serialize, serde::Deserialize)]
struct CategoriaEnfermedad {
    id_categoria_enfermedades: i32,
    nombre_catenfermedades: String,
}

#[derive(serde::Serialize, serde::Deserialize)]
struct EnfermedadConCategoria {
    id_enfermedad: i32,
    nombre: String,
    id_categoria_enfermedades: Option<i32>,
    es_cronica: bool,
    nombre_categoria: Option<String>,
}

#[derive(serde::Serialize, serde::Deserialize)]
struct AntecedenteDetalle {
    id_antecedente: i32,
    id_paciente: i32,
    id_enfermedad: i32,
    nombre_enfermedad: String,
    fecha_diagnostico: String,  // Formato "YYYY-MM-DD"
    tratamiento: Option<String>,
    es_cronica: bool,
}

#[derive(serde::Serialize, serde::Deserialize)]
struct ConsultaTemporal {
    id_consulta: i32,
    id_paciente: i32,  // <-- Mantenemos solo esta relación
    motivo_consulta: String,
    fecha_consulta: String,
    peso: Option<f64>,
    altura: Option<f64>,
    frecuencia_cardiaca: Option<i32>,
    presion_arterial: Option<String>,
    antecedente: Option<String>,       // <-- Ahora es String en lugar de ID
    enfermedades: Option<String>,      // <-- String en lugar de ID
    laboratorio: Option<String>,       // <-- String
    examen_fisico: Option<String>,     // <-- String
    diagnostico: Option<String>,       // <-- String
    proxima_cita: String,
    plan_terapeutico: Option<String>,  // <-- String
}


// Agrega esto cerca de las otras definiciones de structs
#[derive(serde::Serialize, serde::Deserialize)]
struct Consulta {
    id_consulta: i32,
    id_paciente: i32,
    motivo_consulta: String,
    fecha_consulta: String,
    peso: Option<f64>,
    altura: Option<f64>,
    frecuencia_cardiaca: Option<i32>,
    presion_arterial: Option<String>,
    id_antecedente: Option<i32>,
    id_episodio: Option<i32>,
    id_laboratorio: Option<i32>,
    id_examen_fisico: Option<i32>,
    id_diagnostico: Option<i32>,
    proxima_cita: String,
    id_plan_terapeutico: Option<i32>,
}

fn inicializar_bases_datos() -> Result<()> {
    // Conexión a la base de datos original
    let conexion = Connection::open("my-db2.db3").expect("error conectando a sqlite");

    conexion
        .execute(
            "CREATE TABLE IF NOT EXISTS PERSONA(
            id INTEGER PRIMARY KEY,
            nombre TEXT NOT NULL,
            fecha TEXT NULL,
            data BLOB
        )",
            (),
        )
        .expect("Error Creando La Tabla PERSONA");

    // Insertar datos de ejemplo en PERSONA
    conexion
        .execute(
            "INSERT OR IGNORE INTO PERSONA (id, nombre, data, fecha) VALUES (?1, ?2, ?3, ?4)",
            (1, "Maria", Some(vec![3, 4, 1, 2]), Utc::now().to_rfc3339()),
        )
        .expect("Error insertando Maria");

    conexion
        .execute(
            "INSERT OR IGNORE INTO PERSONA (id, nombre, data, fecha) VALUES (?1, ?2, ?3, ?4)",
            (2, "Juan", Some(vec![10, 11]), Utc::now().to_rfc3339()),
        )
        .expect("Error insertando Juan");

    // ========== NUEVA BASE DE DATOS DE CLÍNICA ==========

    // Conexión a la nueva base de datos de clínica
    let conexion_clinica =
        Connection::open("clinica.db").expect("error conectando a base de datos clinica");

    // Crear la tabla paciente
    conexion_clinica
        .execute(
            "CREATE TABLE IF NOT EXISTS paciente (
                Id_paciente INTEGER PRIMARY KEY AUTOINCREMENT,
                Nombre_1 TEXT NOT NULL,
                Nombre_2 TEXT NOT NULL,
                Nombre_3 TEXT,
                Apellido_1 TEXT NOT NULL,
                Apellido_2 TEXT,
                Apellido_casado TEXT,
                Fecha_Nacimiento TEXT NOT NULL,
                Direccion TEXT NOT NULL,
                Telefono TEXT NOT NULL CHECK (LENGTH(Telefono) >= 8 AND Telefono GLOB '[0-9]*'),
                Genero TEXT CHECK (Genero IN ('Masculino', 'Femenino', 'Otro')),
                fecha_registro TEXT DEFAULT CURRENT_TIMESTAMP
            )",
            (),
        )
        .expect("Error creando la tabla paciente");

    // Crear las nuevas tablas y triggers
    conexion_clinica.execute_batch(
        r#"
        -- Tabla de categorías de enfermedades
        CREATE TABLE IF NOT EXISTS categorias_enfermedades (
            id_categoria_enfermedades INTEGER PRIMARY KEY AUTOINCREMENT,
            nombre_catenfermedades TEXT NOT NULL UNIQUE
        );

        -- Tabla de enfermedades
        CREATE TABLE IF NOT EXISTS enfermedades (
            id_enfermedad INTEGER PRIMARY KEY AUTOINCREMENT,
            nombre        TEXT    NOT NULL UNIQUE,
            id_categoria_enfermedades INTEGER,
            es_cronica    BOOLEAN NOT NULL CHECK (es_cronica IN (0, 1)),
            FOREIGN KEY (id_categoria_enfermedades) REFERENCES categorias_enfermedades (id_categoria_enfermedades) 
        );

        -- Tabla de antecedentes patológicos (para crónicas)
        CREATE TABLE IF NOT EXISTS antecedentes_patologicos (
            id_antecedente    INTEGER PRIMARY KEY AUTOINCREMENT,
            id_paciente       INTEGER NOT NULL,
            id_enfermedad     INTEGER NOT NULL,
            fecha_diagnostico TEXT NOT NULL,
            tratamiento       TEXT,
            FOREIGN KEY (id_paciente) REFERENCES paciente (Id_paciente),
            FOREIGN KEY (id_enfermedad) REFERENCES enfermedades (id_enfermedad) 
        );

        -- Tabla de historial de enfermedades (para agudas)
        CREATE TABLE IF NOT EXISTS historial_enfermedades (
            id_episodio   INTEGER PRIMARY KEY AUTOINCREMENT,
            id_paciente   INTEGER NOT NULL,
            id_enfermedad INTEGER NOT NULL,
            fecha_inicio  TEXT NOT NULL,
            fecha_fin     TEXT,
            sintomas      TEXT,
            FOREIGN KEY (id_paciente) REFERENCES paciente (id_paciente),
            FOREIGN KEY (id_enfermedad) REFERENCES enfermedades (id_enfermedad) 
        );

        -- Tabla de tipo de examen
        CREATE TABLE IF NOT EXISTS tipo_examen (
            id_tipo_examen          INTEGER PRIMARY KEY AUTOINCREMENT,
            nombre_tipo_examen      TEXT NOT NULL UNIQUE,
            descripcion_tipo_examen TEXT
        );

        -- Tabla de laboratorios
        CREATE TABLE IF NOT EXISTS laboratorios (
            id_laboratorio  INTEGER PRIMARY KEY AUTOINCREMENT,
            id_tipo_examen  INTEGER NOT NULL,
            id_paciente     INTEGER NOT NULL,
            Fecha_toma      TEXT,
            Fecha_resultado TEXT,
            Observaciones   TEXT,
            Resultado_valor REAL,
            Resultado_texto TEXT CHECK (Resultado_texto IN ('Positivo', 'Negativo', 'Pendiente', 'Otro')) NOT NULL,
            FOREIGN KEY (id_tipo_examen) REFERENCES tipo_examen (id_tipo_examen),
            FOREIGN KEY (id_paciente) REFERENCES paciente (id_paciente) 
        );

        -- Tabla de examen físico
        CREATE TABLE IF NOT EXISTS examen_fisico (
            id_examen_fisico    INTEGER PRIMARY KEY AUTOINCREMENT,
            id_paciente         INTEGER NOT NULL,
            estado_general      TEXT CHECK (estado_general IN ('Consciente orientado', 'Consciente desorientado', 'Decaído', 'Inconsciente')),
            piel_mucosas        TEXT CHECK (piel_mucosas IN ('Normal', 'Pálido', 'Cianótico', 'Ictérico', 'Eritematoso', 'Lesiones presentes')),
            cardiopulmonar      TEXT CHECK (cardiopulmonar IN ('Normal', 'Taquicardia', 'Bradicardia', 'Soplo', 'Sibilancias', 'Crepitantes')),
            abdomen             TEXT CHECK (abdomen IN ('Blando depresible', 'Dolor a la palpación', 'Rigidez', 'Distendido', 'Masas palpables')),
            extremidades        TEXT CHECK (extremidades IN ('Normal', 'Edema', 'Pulsos disminuidos', 'Pulsos ausentes', 'Deformidad')),
            neurologico         TEXT CHECK (neurologico IN ('Normal', 'Reflejos disminuidos', 'Reflejos aumentados', 'Déficit motor', 'Parestesias')),
            extra_examen_fisico TEXT,
            FOREIGN KEY (id_paciente) REFERENCES paciente (id_paciente) 
        );

        -- Tabla de diagnóstico
        CREATE TABLE IF NOT EXISTS diagnostico (
            id_diagnostico          INTEGER PRIMARY KEY AUTOINCREMENT,
            Tipo_diagnostico        TEXT CHECK (Tipo_diagnostico IN ('Principal', 'Secundario', 'Presuntivo')) NOT NULL,
            descripcion_diagnostico TEXT,
            id_paciente             INTEGER NOT NULL,
            FOREIGN KEY (id_paciente) REFERENCES paciente (id_paciente) 
        );

        -- Tabla de plan terapéutico
        CREATE TABLE IF NOT EXISTS plan_terapeutico (
            id_plan_terapeutico INTEGER PRIMARY KEY AUTOINCREMENT,
            id_diagnostico      INTEGER NOT NULL,
            Objetivo            TEXT NOT NULL,
            Recomendaciones     TEXT NOT NULL,
            id_paciente         INTEGER NOT NULL,
            FOREIGN KEY (id_paciente) REFERENCES paciente (id_paciente),
            FOREIGN KEY (id_diagnostico) REFERENCES diagnostico (id_diagnostico) 
        );

        -- Tabla de tratamiento
        CREATE TABLE IF NOT EXISTS tratamiento (
            id_tratamiento       INTEGER PRIMARY KEY AUTOINCREMENT,
            via                  TEXT CHECK (via IN ('Oral', 'IV', 'IM', 'Topica', 'Otro')) NOT NULL,
            duracion_tratamiento TEXT,
            frecuencia           TEXT NOT NULL,
            dosis                TEXT NOT NULL,
            medicamento          TEXT NOT NULL,
            id_paciente          INTEGER NOT NULL,
            id_plan_terapeutico  INTEGER,
            FOREIGN KEY (id_plan_terapeutico) REFERENCES plan_terapeutico(id_plan_terapeutico),
            FOREIGN KEY (id_paciente) REFERENCES paciente (id_paciente)
        );

        -- Tabla de consulta
        CREATE TABLE IF NOT EXISTS consulta (
            id_consulta         INTEGER PRIMARY KEY AUTOINCREMENT,
            id_paciente         INTEGER NOT NULL,
            motivo_consulta     TEXT NOT NULL,
            fecha_consulta      TEXT NOT NULL,
            peso                REAL,
            altura              REAL,
            frecuencia_cardiaca INTEGER,
            presion_arterial    TEXT,
            id_antecedente      INTEGER,
            id_episodio         INTEGER,
            id_laboratorio      INTEGER,
            id_examen_fisico    INTEGER,
            id_diagnostico      INTEGER,
            proxima_cita        TEXT NOT NULL,
            id_plan_terapeutico INTEGER,
            FOREIGN KEY (id_paciente) REFERENCES paciente (id_paciente),
            FOREIGN KEY (id_antecedente) REFERENCES antecedentes_patologicos (id_antecedente),
            FOREIGN KEY (id_episodio) REFERENCES historial_enfermedades (id_episodio),
            FOREIGN KEY (id_laboratorio) REFERENCES laboratorios (id_laboratorio),
            FOREIGN KEY (id_examen_fisico) REFERENCES examen_fisico (id_examen_fisico),
            FOREIGN KEY (id_diagnostico) REFERENCES diagnostico (id_diagnostico),
            FOREIGN KEY (id_plan_terapeutico) REFERENCES plan_terapeutico (id_plan_terapeutico) 
        );

                -- Tabla de consulta
        CREATE TABLE IF NOT EXISTS consultatemporales (
            id_consulta         INTEGER PRIMARY KEY AUTOINCREMENT,
            id_paciente         INTEGER NOT NULL,
            motivo_consulta     TEXT NOT NULL,
            fecha_consulta      TEXT NOT NULL,
            peso                REAL,
            altura              REAL,
            frecuencia_cardiaca INTEGER,
            presion_arterial    TEXT,
            antecedente         INTEGER,
            enfermedades        INTEGER,
            laboratorio      INTEGER,
            examen_fisico    INTEGER,
            diagnostico      INTEGER,
            proxima_cita        TEXT NOT NULL,
            plan_terapeutico INTEGER,
            FOREIGN KEY (id_paciente) REFERENCES paciente (id_paciente)
        );


        -- Tabla de cita
        CREATE TABLE IF NOT EXISTS cita (
            id_cita INTEGER PRIMARY KEY AUTOINCREMENT,
            id_paciente INTEGER NOT NULL,
            fecha_cita  TEXT NOT NULL,
            estado_cita TEXT CHECK (estado_cita IN ('Pendiente', 'Atendida', 'Cancelada')) NOT NULL,
            FOREIGN KEY (id_paciente) REFERENCES paciente (id_paciente) 
        );

        -- Trigger para antecedentes_patologicos (solo enfermedades crónicas)
        CREATE TRIGGER IF NOT EXISTS valida_antecedente_cronico
                BEFORE INSERT ON antecedentes_patologicos
              FOR EACH ROW
        BEGIN
            SELECT CASE WHEN (SELECT es_cronica FROM enfermedades WHERE id_enfermedad = NEW.id_enfermedad) != 1 
            THEN RAISE(ABORT, 'Error: Esta enfermedad no es crónica. Usa historial_enfermedades.') END;
        END;

        -- Trigger para historial_enfermedades (solo enfermedades agudas)
        CREATE TRIGGER IF NOT EXISTS valida_historial_agudo
                BEFORE INSERT ON historial_enfermedades
              FOR EACH ROW
        BEGIN
            SELECT CASE WHEN (SELECT es_cronica FROM enfermedades WHERE id_enfermedad = NEW.id_enfermedad) != 0 
            THEN RAISE(ABORT, 'Error: Esta enfermedad es crónica. Usa antecedentes_patologicos.') END;
        END;
        "#
    ).expect("Error creando tablas adicionales y triggers");

    println!("========== BASES DE DATOS INICIALIZADAS ==========");
    println!("Base de datos 'my-db2.db3' con tabla PERSONA ✓");
    println!("Base de datos 'clinica.db' con todas las tablas y triggers ✓");
    println!("==================================================");

    Ok(())
}

// Comando Tauri para insertar pacientes (preparado para cuando lo necesites)
#[command]
fn insertar_paciente(
    nombre_1: String,
    nombre_2: String,
    nombre_3: Option<String>,
    apellido_1: String,
    apellido_2: Option<String>,
    apellido_casado: Option<String>,
    fecha_nacimiento: String,
    direccion: String,
    telefono: String,
    genero: String,
) -> Result<String, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    conexion
        .execute(
            "INSERT INTO paciente (Nombre_1, Nombre_2, Nombre_3, Apellido_1, Apellido_2, Apellido_casado, Fecha_Nacimiento, Direccion, Telefono, Genero) 
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)",
            (
                &nombre_1,
                &nombre_2,
                &nombre_3,
                &apellido_1,
                &apellido_2,
                &apellido_casado,
                &fecha_nacimiento,
                &direccion,
                &telefono,
                &genero,
            ),
        )
        .map_err(|e| format!("Error insertando paciente: {}", e))?;

    Ok("Paciente insertado exitosamente".to_string())
}

// Comando Tauri para obtener pacientes (preparado para cuando lo necesites)
#[command]
fn obtener_pacientes() -> Result<Vec<Paciente>, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    let mut statement = conexion
        .prepare("SELECT Id_paciente, Nombre_1, Nombre_2, Nombre_3, Apellido_1, Apellido_2, Apellido_casado, Fecha_Nacimiento, Direccion, Telefono, Genero, fecha_registro FROM paciente")
        .map_err(|e| format!("Error preparando consulta: {}", e))?;

    let pacientes_iter = statement
        .query_map([], |row| {
            Ok(Paciente {
                id_paciente: row.get(0)?,
                nombre_1: row.get(1)?,
                nombre_2: row.get(2)?,
                nombre_3: row.get(3)?,
                apellido_1: row.get(4)?,
                apellido_2: row.get(5)?,
                apellido_casado: row.get(6)?,
                fecha_nacimiento: row.get(7)?,
                direccion: row.get(8)?,
                telefono: row.get(9)?,
                genero: row.get(10)?,
                fecha_registro: row.get(11)?,
            })
        })
        .map_err(|e| format!("Error ejecutando consulta: {}", e))?;

    let mut pacientes = Vec::new();
    for paciente in pacientes_iter {
        pacientes.push(paciente.map_err(|e| format!("Error procesando paciente: {}", e))?);
    }

    Ok(pacientes)
}

#[command]
fn obtener_paciente_por_id(id: i32) -> Result<Paciente, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    let mut statement = conexion
        .prepare(
            "SELECT 
                Id_paciente, 
                Nombre_1, 
                Nombre_2, 
                Nombre_3, 
                Apellido_1, 
                Apellido_2, 
                Apellido_casado, 
                Fecha_Nacimiento, 
                Direccion, 
                Telefono, 
                Genero, 
                fecha_registro 
             FROM paciente 
             WHERE Id_paciente = ?1",
        )
        .map_err(|e| format!("Error preparando consulta: {}", e))?;

    match statement.query_row([id], |row| {
        Ok(Paciente {
            id_paciente: row.get(0)?,
            nombre_1: row.get(1)?,
            nombre_2: row.get(2)?,
            nombre_3: row.get(3)?,
            apellido_1: row.get(4)?,
            apellido_2: row.get(5)?,
            apellido_casado: row.get(6)?,
            fecha_nacimiento: row.get(7)?,
            direccion: row.get(8)?,
            telefono: row.get(9)?,
            genero: row.get(10)?,
            fecha_registro: row.get(11)?,
        })
    }) {
        Ok(paciente) => Ok(paciente),
        Err(rusqlite::Error::QueryReturnedNoRows) => {
            Err(format!("No se encontró el paciente con ID {}", id))
        }
        Err(e) => Err(format!("Error obteniendo paciente: {}", e)),
    }
}

#[command]
fn actualizar_paciente(
    id: i32,
    nombre_1: String,
    nombre_2: String,
    nombre_3: Option<String>,
    apellido_1: String,
    apellido_2: Option<String>,
    apellido_casado: Option<String>,
    fecha_nacimiento: String,
    direccion: String,
    telefono: String,
    genero: String,
) -> Result<String, String> {
    let conn = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    conn.execute(
        "UPDATE paciente SET 
            nombre_1 = ?1, 
            nombre_2 = ?2, 
            nombre_3 = ?3, 
            apellido_1 = ?4, 
            apellido_2 = ?5, 
            apellido_casado = ?6, 
            fecha_nacimiento = ?7, 
            direccion = ?8, 
            telefono = ?9, 
            genero = ?10 
        WHERE id_paciente = ?11",
        rusqlite::params![
            nombre_1,
            nombre_2,
            nombre_3,
            apellido_1,
            apellido_2,
            apellido_casado,
            fecha_nacimiento,
            direccion,
            telefono,
            genero,
            id
        ],
    )
    .map_err(|e| format!("Error actualizando paciente: {}", e))?;

    Ok(format!("Paciente con ID {} actualizado correctamente", id))
}

// Agrega estos comandos dentro del #[command] macro, antes del main()

#[command]
fn obtener_consultas() -> Result<Vec<Consulta>, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    let mut statement = conexion
        .prepare("SELECT id_consulta, id_paciente, motivo_consulta, fecha_consulta, peso, altura, frecuencia_cardiaca, presion_arterial, id_antecedente, id_episodio, id_laboratorio, id_examen_fisico, id_diagnostico, proxima_cita, id_plan_terapeutico FROM consulta")
        .map_err(|e| format!("Error preparando consulta: {}", e))?;

    let consultas_iter = statement
        .query_map([], |row| {
            Ok(Consulta {
                id_consulta: row.get(0)?,
                id_paciente: row.get(1)?,
                motivo_consulta: row.get(2)?,
                fecha_consulta: row.get(3)?,
                peso: row.get(4)?,
                altura: row.get(5)?,
                frecuencia_cardiaca: row.get(6)?,
                presion_arterial: row.get(7)?,
                id_antecedente: row.get(8)?,
                id_episodio: row.get(9)?,
                id_laboratorio: row.get(10)?,
                id_examen_fisico: row.get(11)?,
                id_diagnostico: row.get(12)?,
                proxima_cita: row.get(13)?,
                id_plan_terapeutico: row.get(14)?,
            })
        })
        .map_err(|e| format!("Error ejecutando consulta: {}", e))?;

    let mut consultas = Vec::new();
    for consulta in consultas_iter {
        consultas.push(consulta.map_err(|e| format!("Error procesando consulta: {}", e))?);
    }

    Ok(consultas)
}

#[command]
fn obtener_consulta_por_id(id: i32) -> Result<Consulta, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    let mut statement = conexion
        .prepare("SELECT id_consulta, id_paciente, motivo_consulta, fecha_consulta, peso, altura, frecuencia_cardiaca, presion_arterial, id_antecedente, id_episodio, id_laboratorio, id_examen_fisico, id_diagnostico, proxima_cita, id_plan_terapeutico FROM consulta WHERE id_consulta = ?1")
        .map_err(|e| format!("Error preparando consulta: {}", e))?;

    statement
        .query_row([id], |row| {
            Ok(Consulta {
                id_consulta: row.get(0)?,
                id_paciente: row.get(1)?,
                motivo_consulta: row.get(2)?,
                fecha_consulta: row.get(3)?,
                peso: row.get(4)?,
                altura: row.get(5)?,
                frecuencia_cardiaca: row.get(6)?,
                presion_arterial: row.get(7)?,
                id_antecedente: row.get(8)?,
                id_episodio: row.get(9)?,
                id_laboratorio: row.get(10)?,
                id_examen_fisico: row.get(11)?,
                id_diagnostico: row.get(12)?,
                proxima_cita: row.get(13)?,
                id_plan_terapeutico: row.get(14)?,
            })
        })
        .map_err(|e| format!("Error obteniendo consulta: {}", e))
}

#[command]
fn crear_consulta(
    id_paciente: i32,
    motivo_consulta: String,
    fecha_consulta: String,
    peso: Option<f64>,
    altura: Option<f64>,
    frecuencia_cardiaca: Option<i32>,
    presion_arterial: Option<String>,
    id_antecedente: Option<i32>,
    id_episodio: Option<i32>,
    id_laboratorio: Option<i32>,
    id_examen_fisico: Option<i32>,
    id_diagnostico: Option<i32>,
    proxima_cita: String,
    id_plan_terapeutico: Option<i32>,
) -> Result<String, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    conexion
        .execute(
            "INSERT INTO consulta (
                id_paciente, motivo_consulta, fecha_consulta, peso, altura, 
                frecuencia_cardiaca, presion_arterial, id_antecedente, id_episodio, 
                id_laboratorio, id_examen_fisico, id_diagnostico, proxima_cita, id_plan_terapeutico
            ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14)",
            rusqlite::params![
                id_paciente,
                motivo_consulta,
                fecha_consulta,
                peso,
                altura,
                frecuencia_cardiaca,
                presion_arterial,
                id_antecedente,
                id_episodio,
                id_laboratorio,
                id_examen_fisico,
                id_diagnostico,
                proxima_cita,
                id_plan_terapeutico
            ],
        )
        .map_err(|e| format!("Error insertando consulta: {}", e))?;

    Ok("Consulta creada exitosamente".to_string())
}

#[command]
fn obtener_categorias_enfermedades() -> Result<Vec<CategoriaEnfermedad>, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    let mut statement = conexion
        .prepare(
            "SELECT id_categoria_enfermedades, nombre_catenfermedades FROM categorias_enfermedades",
        )
        .map_err(|e| format!("Error preparando consulta: {}", e))?;

    let categorias_iter = statement
        .query_map([], |row| {
            Ok(CategoriaEnfermedad {
                id_categoria_enfermedades: row.get(0)?,
                nombre_catenfermedades: row.get(1)?,
            })
        })
        .map_err(|e| format!("Error ejecutando consulta: {}", e))?;

    let mut categorias = Vec::new();
    for categoria in categorias_iter {
        categorias.push(categoria.map_err(|e| format!("Error procesando categoría: {}", e))?);
    }

    Ok(categorias)
}

#[command]
fn crear_categoria_enfermedad(nombre: String) -> Result<String, String> {
    let conn = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    conn.execute(
        "INSERT INTO categorias_enfermedades (nombre_catenfermedades) VALUES (?1)",
        [&nombre],
    )
    .map_err(|e| format!("Error insertando categoría: {}", e))?;

    Ok("Categoría creada exitosamente".to_string())
}

#[command]
fn actualizar_categoria_enfermedad(id: i32, nombre: String) -> Result<String, String> {
    let conn = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    conn.execute(
        "UPDATE categorias_enfermedades SET nombre_catenfermedades = ?1 WHERE id_categoria_enfermedades = ?2",
        [&nombre, &id.to_string()]
    )
    .map_err(|e| format!("Error actualizando categoría: {}", e))?;

    Ok("Categoría actualizada exitosamente".to_string())
}

#[command]
fn eliminar_categoria_enfermedad(id: i32) -> Result<String, String> {
    let conn = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    conn.execute(
        "DELETE FROM categorias_enfermedades WHERE id_categoria_enfermedades = ?1",
        [id],
    )
    .map_err(|e| format!("Error eliminando categoría: {}", e))?;

    Ok("Categoría eliminada exitosamente".to_string())
}
// ============ENFERMEDADES=============
// Obtener todas las enfermedades
#[command]
fn obtener_enfermedades() -> Result<Vec<EnfermedadConCategoria>, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    let mut stmt = conexion.prepare(
        "SELECT 
            e.id_enfermedad, 
            e.nombre, 
            e.id_categoria_enfermedades, 
            e.es_cronica,
            c.nombre_catenfermedades
         FROM enfermedades e
         LEFT JOIN categorias_enfermedades c ON e.id_categoria_enfermedades = c.id_categoria_enfermedades"
    ).map_err(|e| format!("Error preparando consulta: {}", e))?;

    let enfermedades_iter = stmt.query_map([], |row| {
        Ok(EnfermedadConCategoria {
            id_enfermedad: row.get(0)?,
            nombre: row.get(1)?,
            id_categoria_enfermedades: row.get(2)?,
            es_cronica: row.get(3)?,
            nombre_categoria: row.get(4)?,
        })
    }).map_err(|e| format!("Error ejecutando consulta: {}", e))?;

    let mut enfermedades = Vec::new();
    for enfermedad in enfermedades_iter {
        enfermedades.push(enfermedad.map_err(|e| format!("Error procesando fila: {}", e))?);
    }

    Ok(enfermedades)
}


// Crear una nueva enfermedad
#[command]
fn crear_enfermedad(
    nombre: String,
    id_categoria: Option<i32>,
    es_cronica: bool,
) -> Result<String, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    conexion
        .execute(
            "INSERT INTO enfermedades (nombre, id_categoria_enfermedades, es_cronica) 
             VALUES (?1, ?2, ?3)",
            (&nombre, &id_categoria, &es_cronica),
        )
        .map_err(|e| format!("Error insertando enfermedad: {}", e))?;

    Ok("Enfermedad creada exitosamente".to_string())
}
// Actualizar una enfermedad existente
#[command]
fn actualizar_enfermedad(
    id: i32,
    nombre: String,
    id_categoria: Option<i32>,
    es_cronica: bool,
) -> Result<String, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    conexion
        .execute(
            "UPDATE enfermedades 
             SET nombre = ?1, id_categoria_enfermedades = ?2, es_cronica = ?3 
             WHERE id_enfermedad = ?4",
            (&nombre, &id_categoria, &es_cronica, &id),
        )
        .map_err(|e| format!("Error actualizando enfermedad: {}", e))?;

    Ok("Enfermedad actualizada exitosamente".to_string())
}

// Eliminar una enfermedad
#[command]
fn eliminar_enfermedad(id: i32) -> Result<String, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    conexion
        .execute("DELETE FROM enfermedades WHERE id_enfermedad = ?1", [id])
        .map_err(|e| format!("Error eliminando enfermedad: {}", e))?;

    Ok("Enfermedad eliminada exitosamente".to_string())
}

// Obtener enfermedad por ID con información de categoría
#[command]
fn obtener_enfermedad_por_id(id: i32) -> Result<EnfermedadConCategoria, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    let mut stmt = conexion
        .prepare(
            "SELECT 
                e.id_enfermedad, 
                e.nombre, 
                e.id_categoria_enfermedades, 
                e.es_cronica,
                c.nombre_catenfermedades
             FROM enfermedades e
             LEFT JOIN categorias_enfermedades c ON e.id_categoria_enfermedades = c.id_categoria_enfermedades
             WHERE e.id_enfermedad = ?1",
        )
        .map_err(|e| format!("Error preparando consulta: {}", e))?;

    stmt.query_row([id], |row| {
        Ok(EnfermedadConCategoria {
            id_enfermedad: row.get(0)?,
            nombre: row.get(1)?,
            id_categoria_enfermedades: row.get(2)?,
            es_cronica: row.get(3)?,
            nombre_categoria: row.get(4)?,
        })
    })
    .map_err(|e| match e {
        rusqlite::Error::QueryReturnedNoRows => {
            format!("No se encontró la enfermedad con ID {}", id)
        }
        _ => format!("Error obteniendo enfermedad: {}", e),
    })
}

// ============ ANTECEDENTES PATOLÓGICOS ============

#[command]
fn crear_antecedente(
    id_paciente: i32,
    id_enfermedad: i32,
    fecha_diagnostico: String,
    tratamiento: Option<String>,
) -> Result<String, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    conexion
        .execute(
            "INSERT INTO antecedentes_patologicos (id_paciente, id_enfermedad, fecha_diagnostico, tratamiento) 
             VALUES (?1, ?2, ?3, ?4)",
            (&id_paciente, &id_enfermedad, &fecha_diagnostico, &tratamiento),
        )
        .map_err(|e| format!("Error insertando antecedente: {}", e))?;

    Ok("Antecedente creado exitosamente".to_string())
}

#[command]
fn obtener_antecedentes_por_paciente(id_paciente: i32) -> Result<Vec<AntecedenteDetalle>, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    let mut stmt = conexion
        .prepare(
            "SELECT 
                a.id_antecedente, 
                a.id_paciente, 
                a.id_enfermedad, 
                e.nombre as nombre_enfermedad,
                a.fecha_diagnostico, 
                a.tratamiento,
                e.es_cronica
             FROM antecedentes_patologicos a
             JOIN enfermedades e ON a.id_enfermedad = e.id_enfermedad
             WHERE a.id_paciente = ?1",
        )
        .map_err(|e| format!("Error preparando consulta: {}", e))?;

    let antecedentes_iter = stmt
        .query_map([id_paciente], |row| {
            Ok(AntecedenteDetalle {
                id_antecedente: row.get(0)?,
                id_paciente: row.get(1)?,
                id_enfermedad: row.get(2)?,
                nombre_enfermedad: row.get(3)?,
                fecha_diagnostico: row.get(4)?,
                tratamiento: row.get(5)?,
                es_cronica: row.get(6)?,
            })
        })
        .map_err(|e| format!("Error ejecutando consulta: {}", e))?;

    let mut antecedentes = Vec::new();
    for antecedente in antecedentes_iter {
        antecedentes.push(antecedente.map_err(|e| format!("Error procesando fila: {}", e))?);
    }

    Ok(antecedentes)
}

#[command]
fn obtener_antecedente_por_id(id_antecedente: i32) -> Result<AntecedenteDetalle, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    let mut stmt = conexion
        .prepare(
            "SELECT 
                a.id_antecedente, 
                a.id_paciente, 
                a.id_enfermedad, 
                e.nombre as nombre_enfermedad,
                a.fecha_diagnostico, 
                a.tratamiento,
                e.es_cronica
             FROM antecedentes_patologicos a
             JOIN enfermedades e ON a.id_enfermedad = e.id_enfermedad
             WHERE a.id_antecedente = ?1",
        )
        .map_err(|e| format!("Error preparando consulta: {}", e))?;

    stmt.query_row([id_antecedente], |row| {
        Ok(AntecedenteDetalle {
            id_antecedente: row.get(0)?,
            id_paciente: row.get(1)?,
            id_enfermedad: row.get(2)?,
            nombre_enfermedad: row.get(3)?,
            fecha_diagnostico: row.get(4)?,
            tratamiento: row.get(5)?,
            es_cronica: row.get(6)?,
        })
    })
    .map_err(|e| match e {
        rusqlite::Error::QueryReturnedNoRows => {
            format!("No se encontró el antecedente con ID {}", id_antecedente)
        }
        _ => format!("Error obteniendo antecedente: {}", e),
    })
}

#[command]
fn actualizar_antecedente(
    id_antecedente: i32,
    id_enfermedad: i32,
    fecha_diagnostico: String,
    tratamiento: Option<String>,
) -> Result<String, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    conexion
        .execute(
            "UPDATE antecedentes_patologicos 
             SET id_enfermedad = ?1, fecha_diagnostico = ?2, tratamiento = ?3 
             WHERE id_antecedente = ?4",
            (&id_enfermedad, &fecha_diagnostico, &tratamiento, &id_antecedente),
        )
        .map_err(|e| format!("Error actualizando antecedente: {}", e))?;

    Ok("Antecedente actualizado exitosamente".to_string())
}

#[command]
fn eliminar_antecedente(id_antecedente: i32) -> Result<String, String> {
    let conexion = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando a la base de datos: {}", e))?;

    // Primero verificar si el antecedente está siendo usado en alguna consulta
    let mut stmt = conexion
        .prepare("SELECT COUNT(*) FROM consulta WHERE id_antecedente = ?1")
        .map_err(|e| format!("Error preparando consulta: {}", e))?;

    let count: i32 = stmt
        .query_row([id_antecedente], |row| row.get(0))
        .map_err(|e| format!("Error verificando uso del antecedente: {}", e))?;

    if count > 0 {
        return Err("No se puede eliminar el antecedente porque está asociado a una o más consultas".to_string());
    }

    conexion
        .execute(
            "DELETE FROM antecedentes_patologicos WHERE id_antecedente = ?1",
            [id_antecedente],
        )
        .map_err(|e| format!("Error eliminando antecedente: {}", e))?;

    Ok("Antecedente eliminado exitosamente".to_string())
}


//================CONSULTAS TEMPORALES ================//
#[command]
fn crear_consulta_temporal(
    idPaciente: i32,                    // ✅ Cambiar a camelCase
    motivoConsulta: String,             // ✅ Cambiar a camelCase
    fechaConsulta: String,              // ✅ Cambiar a camelCase
    peso: Option<f64>,
    altura: Option<f64>,
    frecuenciaCardiaca: Option<i32>,    // ✅ Cambiar a camelCase
    presionArterial: Option<String>,    // ✅ Cambiar a camelCase
    antecedente: Option<String>,
    enfermedades: Option<String>,
    laboratorio: Option<String>,
    examenFisico: Option<String>,       // ✅ Cambiar a camelCase
    diagnostico: Option<String>,
    proximaCita: String,                // ✅ Cambiar a camelCase
    planTerapeutico: Option<String>,    // ✅ Cambiar a camelCase
) -> Result<String, String> {
    let conn = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando: {}", e))?;

    conn.execute(
        "INSERT INTO consultatemporales (
            id_paciente, motivo_consulta, fecha_consulta, peso, altura,
            frecuencia_cardiaca, presion_arterial, antecedente, enfermedades,
            laboratorio, examen_fisico, diagnostico, proxima_cita, plan_terapeutico
        ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14)",
        rusqlite::params![
            idPaciente,         // ✅ Usar el nuevo nombre
            motivoConsulta,     // ✅ Usar el nuevo nombre
            fechaConsulta,      // ✅ Usar el nuevo nombre
            peso,
            altura,
            frecuenciaCardiaca, // ✅ Usar el nuevo nombre
            presionArterial,    // ✅ Usar el nuevo nombre
            antecedente,
            enfermedades,
            laboratorio,
            examenFisico,       // ✅ Usar el nuevo nombre
            diagnostico,
            proximaCita,        // ✅ Usar el nuevo nombre
            planTerapeutico     // ✅ Usar el nuevo nombre
        ],
    )
    .map_err(|e| format!("Error insertando: {}", e))?;

    Ok("Consulta temporal creada".into())
}

#[command]
fn obtener_consultas_temporales() -> Result<Vec<ConsultaTemporal>, String> {
    let conn = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando: {}", e))?;

    let mut stmt = conn
        .prepare("SELECT * FROM consultatemporales")
        .map_err(|e| format!("Error preparando: {}", e))?;

    let consultas = stmt
        .query_map([], |row| {
            Ok(ConsultaTemporal {
                id_consulta: row.get(0)?,
                id_paciente: row.get(1)?,
                motivo_consulta: row.get(2)?,
                fecha_consulta: row.get(3)?,
                peso: row.get(4)?,
                altura: row.get(5)?,
                frecuencia_cardiaca: row.get(6)?,
                presion_arterial: row.get(7)?,
                antecedente: row.get(8)?,
                enfermedades: row.get(9)?,
                laboratorio: row.get(10)?,
                examen_fisico: row.get(11)?,
                diagnostico: row.get(12)?,
                proxima_cita: row.get(13)?,
                plan_terapeutico: row.get(14)?,
            })
        })
        .map_err(|e| format!("Error ejecutando: {}", e))?
        .collect::<Result<Vec<_>, _>>()
        .map_err(|e| format!("Error procesando: {}", e))?;

    Ok(consultas)
}

#[command]
fn obtener_consulta_temporal_por_id(id: i32) -> Result<ConsultaTemporal, String> {
    let conn = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando: {}", e))?;

    conn.query_row(
        "SELECT * FROM consultatemporales WHERE id_consulta = ?1",
        [id],
        |row| {
            Ok(ConsultaTemporal {
                id_consulta: row.get(0)?,
                id_paciente: row.get(1)?,
                motivo_consulta: row.get(2)?,
                fecha_consulta: row.get(3)?,
                peso: row.get(4)?,
                altura: row.get(5)?,
                frecuencia_cardiaca: row.get(6)?,
                presion_arterial: row.get(7)?,
                antecedente: row.get(8)?,
                enfermedades: row.get(9)?,
                laboratorio: row.get(10)?,
                examen_fisico: row.get(11)?,
                diagnostico: row.get(12)?,
                proxima_cita: row.get(13)?,
                plan_terapeutico: row.get(14)?,
            })
        },
    )
    .map_err(|e| format!("Error obteniendo consulta: {}", e))
}


#[command]
fn actualizar_consulta_temporal(
    id_consulta: i32,
    motivo_consulta: String,
    fecha_consulta: String,
    peso: Option<f64>,
    altura: Option<f64>,
    frecuencia_cardiaca: Option<i32>,
    presion_arterial: Option<String>,
    antecedente: Option<String>,
    enfermedades: Option<String>,
    laboratorio: Option<String>,
    examen_fisico: Option<String>,
    diagnostico: Option<String>,
    proxima_cita: String,
    plan_terapeutico: Option<String>,
) -> Result<String, String> {
    let conn = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando: {}", e))?;

    conn.execute(
        "UPDATE consultatemporales SET
            motivo_consulta = ?1,
            fecha_consulta = ?2,
            peso = ?3,
            altura = ?4,
            frecuencia_cardiaca = ?5,
            presion_arterial = ?6,
            Antecedente = ?7,
            Enfermedades = ?8,
            Laboratorio = ?9,
            Examen_fisico = ?10,
            Diagnostico = ?11,
            proxima_cita = ?12,
            Plan_terapeutico = ?13
        WHERE id_consulta = ?14",
        rusqlite::params![
            motivo_consulta,
            fecha_consulta,
            peso,
            altura,
            frecuencia_cardiaca,
            presion_arterial,
            antecedente,
            enfermedades,
            laboratorio,
            examen_fisico,
            diagnostico,
            proxima_cita,
            plan_terapeutico,
            id_consulta
        ],
    )
    .map_err(|e| format!("Error actualizando: {}", e))?;

    Ok("Consulta temporal actualizada".into())
}

#[command]
fn eliminar_consulta_temporal(id_consulta: i32) -> Result<String, String> {
    let conn = Connection::open("clinica.db")
        .map_err(|e| format!("Error conectando: {}", e))?;

    conn.execute(
        "DELETE FROM consultatemporales WHERE id_consulta = ?1",
        [id_consulta],
    )
    .map_err(|e| format!("Error eliminando: {}", e))?;

    Ok("Consulta temporal eliminada".into())
}



fn main() {
    // Inicializar las bases de datos al arrancar la aplicación
    inicializar_bases_datos().expect("Error inicializando bases de datos");

    // Iniciar la aplicación Tauri
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            insertar_paciente,
            obtener_pacientes,
            obtener_paciente_por_id,
            actualizar_paciente,
            obtener_consultas,
            obtener_consulta_por_id,
            crear_consulta,
            obtener_categorias_enfermedades,
            crear_categoria_enfermedad,
            actualizar_categoria_enfermedad,
            eliminar_categoria_enfermedad,
            obtener_enfermedades,
            obtener_enfermedad_por_id,
            crear_enfermedad,
            actualizar_enfermedad,
            eliminar_enfermedad,
            crear_antecedente,
            obtener_antecedentes_por_paciente,
            obtener_antecedente_por_id,
            actualizar_antecedente,
            eliminar_antecedente,
                        crear_consulta_temporal,
            obtener_consultas_temporales,
            obtener_consulta_temporal_por_id,
            actualizar_consulta_temporal,
            eliminar_consulta_temporal
        ])
        .run(tauri::generate_context!())
        .expect("Error al iniciar Tauri");
}
